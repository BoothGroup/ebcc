import numpy as np
import copy
from pyscf import scf, ao2mo, lib
from . import utils, ccsd_equations, ccsd_1_1_equations, ccsd_2_1_equations, ccsd_2_2_equations

class EBCCSD:

    def __init__(self, mol, mf, eri, options=None, rank=(2, 0, 0), omega=None, gmat=None, shift=True, autogen_code=False):
        ''' Set up EBCCSD class. 

        Args:
            mol: pyscf mol object

            mf: pyscf mf object. Used to compute eris/Fock etc. 
            Note that mf will always be stored as a UHF object, and will be converted from RHF if necessary.

            eri: eri object. We initially assume that this is a 4D tensor of spatial 
                 non-antisymmetrized integrals in chemical notation, for the underlying AOs.

            options: Dict of options for converging calculations

            rank: Rank of excitations in fermionic component of ansatz, Bosonic component, and coupling component respectively (tuple)

            omega: Vector of length ... giving boson frequencies. Length will be used to determine number of bosons

            gmat: electron-boson coupling matrix, of dim (nbos, nao, nao), where nao is the number of spatial orbitals.
                  Fermionic orbital basis is the AO representation, so there are no spin-dependent couplings (this could be relaxed later).

            autogen_code:   Whether to preferentially use autogenerated code rather than optimized code, where there is a choice

        '''

        if options is None:
            self.options = dict()
        else:
            self.options = options
        
        if 'ethresh' not in self.options:
            self.options['ethresh'] = 1.e-8
        if 'tthresh' not in self.options:
            self.options['tthresh'] = 1.e-7
        if 'max_iter' not in self.options:
            self.options['max_iter'] = 500
        if 'damp' not in self.options and 'diis space' not in self.options:
            self.options['damp'] = 0.4
            self.options['diis space'] = None
        if 'damp' in self.options and 'diis space' not in self.options:
            self.options['diis space'] = None
        if 'diis space' in self.options and 'damp' not in self.options:
            self.options['damp'] = 1.0

        if isinstance(mf, scf.rhf.RHF):
            self.mf = scf.addons.convert_to_uhf(mf)
        elif isinstance(mf, scf.uhf.UHF):
            self.mf = copy.copy(mf)
        else:
            raise NotImplementedError
        self.mol = mol

        if rank not in [(2, 0, 0), (2, 1, 1), (2, 2, 1), (2, 2, 2)]:
            raise NotImplementedError
        else:
            self.rank = rank

        print('Running eb-ccsd code:')
        print('Rank of fermionic cluster excitations: {}'.format(self.rank[0]))
        print('Rank of bosonic cluster excitations: {}'.format(self.rank[1]))
        print('Rank of bosonic coupling to 1e fermionic cluster excitations: {}'.format(self.rank[2]))

        self.autogen = autogen_code

        self.omega = omega
        # Electron-boson coupling
        self.gmat = gmat

        # Number of spatial orbitals
        #self.nao = self.mf.mol.nao_nr()
        self.nao = self.mf.mo_coeff[0].shape[1]
        # Number of spinorbitals
        self.nso = 2*self.nao
        
        # One-electron fermionic matrix as a block diagonal aa, bb matrix
        t = self.mf.get_hcore()
        self.tmat = utils.block_diag(t,t)
        
        # Alpha and beta electron numbers
        self.na, self.nb = int(self.mf.mo_occ[0].sum()), int(self.mf.mo_occ[1].sum())
        # Number of alpha and beta virtual orbitals
        self.va, self.vb = self.nao - self.na, self.nao - self.nb
        # Number of occupied and virtual spinorbitals
        self.no = self.na + self.nb
        self.nv = self.nso - self.no

        # Alpha and beta density matrices
        self.pa = np.einsum('ai,bi->ab',self.mf.mo_coeff[0][:,:self.na], self.mf.mo_coeff[0][:,:self.na])
        self.pb = np.einsum('ai,bi->ab',self.mf.mo_coeff[1][:,:self.nb], self.mf.mo_coeff[1][:,:self.nb])
        self.ptot = utils.block_diag(self.pa, self.pb)

        # Construct bare fermionic Fock matrix in block diagonal spin-orbital form, in the AO basis
        fock_u = (t,t) + self.mf.get_veff(self.mol, dm=(self.pa,self.pb))
        # Get it in ghf formal
        self.bare_fock = utils.block_diag(fock_u[0],fock_u[1])
        
        #e, v = np.linalg.eigh(self.bare_fock)

        if self.rank != (2,0,0):
            assert(self.omega is not None)
            # We have bosons specified
            self.nbos = len(omega)
            assert(self.gmat.shape == (self.nbos, self.nao, self.nao))
            # Construct self.gmatso, which stores the spin-orbital version of gmat correctly (i.e. of dimension nbos, nso, nso)
            gmatso = [utils.block_diag(self.gmat[i], self.gmat[i]) for i in range(len(self.gmat))]
            self.gmatso = np.asarray(gmatso)
            # Transform g into the spin-orbital MO representation,
            # and store in occ/virt blocks (note not a tuple of these as in epcc, as required for complex couplings)
            self.g_mo_blocks = self.g_traf()

            # Whether to shift to normal-ordering (removing coupling to HF density of the bosons).
            # If this is True, it will change the fermionic Fock matrix, and introduce an energy shift
            self.shift = shift
            if self.shift:
                # xi is a vector of length nbos, giving the shift in bosonic operators to diagonalize the phononic hamiltonian
                # ie. g<n_i>/omega
                self.xi = np.einsum('Iab,ab->I', self.gmatso, self.ptot) / self.omega
                self.const = -np.einsum('I,I->',self.omega, self.xi**2)
                print('Shift in the energy from moving to polaritonic basis: {}'.format(self.const))
            else:
                self.xi = np.zeros_like(self.omega)
                self.const = 0.0

            # Get 1-boson vector of terms (note not a tuple of the same array as in epcc, as required for complex couplings)
            self.G = self.mfG()
        else:
            # No bosonic part
            self.shift = False
            self.const = 0.0
            self.gmatso = None
            self.nbos = 0

        print('Number of bosonic modes: {}'.format(self.nbos))
        
        # Get MO, spinorb Fock matrix
        self.fock_mo = self.get_fock()
        # Take spinorbital energies as diagonal
        self.eo = np.diag(self.fock_mo.oo)
        self.ev = np.diag(self.fock_mo.vv)
        assert(len(self.eo)==(self.na+self.nb))

        self.ehf = self.hf_energy()
        print('Occupied spinorbital energies: ')
        print(self.eo)
        print('Virtual spinorbital energies: ')
        print(self.ev)
        print('Hartree-Fock energy computed to be: {}'.format(self.ehf))
                
        # Form matrix of ei-ea energy denominators
        self.D1 = self.eo[:,None] - self.ev[None,:]
        # Form matrix of ei+ej-ea-eb energy denominators
        self.D2 = self.eo[:,None,None,None] + self.eo[None,:,None,None] \
                - self.ev[None,None,:,None] - self.ev[None,None,None,:]
        
        # Get antisymmetrized, spinorb MO fermionic interaction integrals in the physicists notation
        self.I = self.get_two_ferm_interactions(eri)

        # Get arrays for required ansatz, and set to initial PT2 values
        self.T1old = self.fock_mo.vo / self.D1.transpose((1,0)) # Note (virt, occ)
        self.T1 = self.T1old.copy() # Note (virt, occ)
        self.amp_vec_size = self.T1.size
        self.t1_bound = self.T1.size

        self.T2old = self.I.vvoo / self.D2.transpose((2,3,0,1)) # Note (virt, virt, occ, occ)
        self.T2 = self.T2old.copy()
        self.amp_vec_size += self.T2.size
        self.t2_bound = self.amp_vec_size

        if self.rank != (2, 0, 0):
            # Compared to epcc, g=h, since we are only ever dealing with real-valued couplings(?)
            g, h = self.g_mo_blocks, self.g_mo_blocks
            # Similarly for the G components of the 1-boson term
            G, H = self.G, self.G

        if self.rank[1] >= 1:
            # Build MP2 S1 amplitudes (b terms)
            self.S1old = -H / self.omega
            self.S1 = self.S1old.copy()
            self.amp_vec_size += self.S1.size
            self.s1_bound = self.amp_vec_size
        else:
            self.S1old = None
            self.S1 = None
        
        if self.rank[2] >= 1:
            # Build the U terms (eb terms)
            # Form the matrix of ei - ea - omega, of dimension (nbos,no,nv)
            self.D1p = self.eo[None,:,None] - self.ev[None,None,:] - self.omega[:,None,None]

            self.U11old = h.vo / self.D1p.transpose((0, 2, 1))
            self.U11 = np.zeros_like(self.U11old)
            self.amp_vec_size += self.U11.size
            self.u11_bound = self.amp_vec_size
        else:
            self.U11old = None
            self.U11 = None

        if self.rank[1] == 2:
            self.Ds2 = -self.omega[:, None] - self.omega[None, :]

            self.S2old = np.zeros((self.nbos, self.nbos))
            self.S2 = np.zeros((self.nbos, self.nbos))
            self.amp_vec_size += self.S2.size
            self.s2_bound = self.amp_vec_size
        else:
            self.S2old = None
            self.S2 = None

        if self.rank[2] == 2:
            # NOTE: Bug in epcc code, which is why we don't get agreement in this model.
            # epcc code has self.omega[:,None,None], rather than self.omega[:,None,None,None] for the energy denominators of U12
            self.D2p = self.eo[None,None,:,None] - self.ev[None,None,None,:] - self.omega[:,None,None,None] - self.omega[None,:,None,None]
            #self.D2p = self.eo[None,None,:,None] - self.ev[None,None,None,:] - self.omega[:,None,None] - self.omega[None,:,None,None]

            self.U12old = np.zeros((self.nbos, self.nbos, self.nv, self.no))    # (nbos, nbos, nvir, nocc)
            self.U12 = np.zeros((self.nbos, self.nbos, self.nv, self.no))    # (nbos, nbos, nvir, nocc)
            self.amp_vec_size += self.U12.size
        else:
            self.U12old = None
            self.U12 = None

        if self.options['diis space'] != None:
            print('Setting up DIIS object, storing {} sets of amplitudes...'.format(options['diis space']))
            self.adiis = lib.diis.DIIS()
            self.adiis.space = self.options['diis space']
        else:
            self.adiis = None

        self.converged_t = False
        self.converged_l = False
        self.e_corr = None

    def get_fock(self):
        ''' Get the Fock matrix in the MO basis. If a phononic shift is applied, this is included in the definition.
        The oo, ov, vo and vv components of this matrix are split up, and stored in a one_e_blocks object, where
        the individual components can be accessed as attributes'''

        # Block diagonal alpha and beta occupied MOs
        Co = utils.block_diag(self.mf.mo_coeff[0][:,:self.na], self.mf.mo_coeff[1][:,:self.nb])
        # Block diagonal alpha and beta virtual MOs
        Cv = utils.block_diag(self.mf.mo_coeff[0][:,self.na:], self.mf.mo_coeff[1][:,self.nb:])
        if self.shift:
            # Subtract the bosonic part from the normal ordering
            Foo = np.einsum('pi,pq,qj->ij',Co,self.bare_fock,Co) - 2*np.einsum('I,pi,Ipq,qj->ij',self.xi, Co, self.gmatso, Co)
            Fov = np.einsum('pi,pq,qa->ia',Co,self.bare_fock,Cv) - 2*np.einsum('I,pi,Ipq,qa->ia',self.xi, Co, self.gmatso, Cv)
            Fvo = np.einsum('pa,pq,qi->ai',Cv,self.bare_fock,Co) - 2*np.einsum('I,pa,Ipq,qi->ai',self.xi, Cv, self.gmatso, Co)
            Fvv = np.einsum('pa,pq,qb->ab',Cv,self.bare_fock,Cv) - 2*np.einsum('I,pa,Ipq,qb->ab',self.xi, Cv, self.gmatso, Cv)
        else:
            Foo = np.einsum('pi,pq,qj->ij',Co,self.bare_fock,Co)
            Fov = np.einsum('pi,pq,qa->ia',Co,self.bare_fock,Cv)
            Fvo = np.einsum('pa,pq,qi->ai',Cv,self.bare_fock,Co)
            Fvv = np.einsum('pa,pq,qb->ab',Cv,self.bare_fock,Cv)
        return utils.one_e_blocks(Foo, Fov, Fvo, Fvv)

    def get_two_ferm_interactions(self, eri):
        ''' Args:
            eri: Chemical, spatial orbital non-symmetrized integrals. Note no permutational symmetry should be used.

            Store as a two_e_blocks object in order to access individual components.
            The integrals are stored as antisymmetrized, physicist notation integrals.
            TODO: Should probably get eris from the mf object, rather than generating them from mol. This is require
            reordering them in a particular way.
        '''

        assert(eri.size == self.nao**4)

        ## recast integrals to a 'generalized' format, where we stack
        ## alpha and beta orbitals together.
        ## aaaa, aabb, bbaa and bbbb blocks allowed.
        #eri_g = np.zeros((self.nso, self.nso, self.nso, self.nso))
        #eri_g[:self.nao, :self.nao, :self.nao, :self.nao] = eri.reshape([self.nao,]*4)
        #eri_g[self.nao:, self.nao:, :self.nao, :self.nao] = eri.reshape([self.nao,]*4)
        #eri_g[:self.nao, :self.nao, self.nao:, self.nao:] = eri.reshape([self.nao,]*4)
        #eri_g[self.nao:, self.nao:, self.nao:, self.nao:] = eri.reshape([self.nao,]*4)
        
        # Get full array of alpha then beta orbitals
        C = np.hstack((self.mf.mo_coeff[0], self.mf.mo_coeff[1]))

        eri1 = np.einsum('ai,abcd->ibcd',C,eri)
        eri2 = np.einsum('bj,ibcd->ijcd',C,eri1)
        eri3 = np.einsum('ck,ijcd->ijkd',C,eri2)
        # Integrals now transformed, and in MO spin-orbital basis
        eri_g = np.einsum('dl,ijkd->ijkl',C,eri3)

        # Impose spin symmetry
        eri_g[:self.nao, self.nao:] = 0.0
        eri_g[self.nao:, :self.nao] = 0.0
        eri_g[:,:,:self.nao, self.nao:] = 0.0
        eri_g[:,:,self.nao:, :self.nao] = 0.0

        ## Get chemical notation eris from pyscf in generalized basis (i.e. the full block of alpha, beta MOs in each dim)
        #eri = ao2mo.general(self.mol, [C,]*4, compact=False).reshape([self.nso,]*4)
        ## Zero spin forbidden sectors
        #eri[:self.nao, self.nao:] = eri[self.nao:, :self.nao] = eri[:,:,:self.nao, self.nao:] = eri[:,:,self.nao:,:self.nao] = 0.0

        # Convert to antisymmetrized physicist notation integrals
        Ua_mo = eri_g.transpose(0,2,1,3) - eri_g.transpose(0,2,3,1)

        # Reorder integrals, s.t. ordering is occupied,alpha, occupied,beta
        temp = [i for i in range(self.nso)]
        oidx = temp[:self.na] + temp[self.nao:self.nao + self.nb]
        vidx = temp[self.na:self.nao] + temp[self.nao + self.nb:]

        # Separate into GHF blocks
        vvvv = Ua_mo[np.ix_(vidx,vidx,vidx,vidx)]
        vvvo = Ua_mo[np.ix_(vidx,vidx,vidx,oidx)]
        vovv = Ua_mo[np.ix_(vidx,oidx,vidx,vidx)]
        vvoo = Ua_mo[np.ix_(vidx,vidx,oidx,oidx)]
        oovv = Ua_mo[np.ix_(oidx,oidx,vidx,vidx)]
        vovo = Ua_mo[np.ix_(vidx,oidx,vidx,oidx)]
        vooo = Ua_mo[np.ix_(vidx,oidx,oidx,oidx)]
        ooov = Ua_mo[np.ix_(oidx,oidx,oidx,vidx)]
        oooo = Ua_mo[np.ix_(oidx,oidx,oidx,oidx)]
        return utils.two_e_blocks(vvvv=vvvv,vvvo=vvvo, vovv=vovv, vvoo=vvoo, oovv=oovv,vovo=vovo, vooo=vooo, ooov=ooov, oooo=oooo)

    def mfG(self):
        '''Get the bosonic creation/annihilation term which arises if you are normal ordering the bosonic part wrt HF reference.
           This returns a nbos length array
        '''

        if self.shift:
            # No term if shifting?
            return np.zeros(self.nbos)
        else:
            return np.einsum('Ipq,qp->I',self.gmatso,self.ptot)

    def g_traf(self):
        ''' Transform the electron-boson coupling term to the MO basis, and store in occupied/virtual blocks.'''
        
        # Block diagonal alpha and beta occupied MOs
        Co = utils.block_diag(self.mf.mo_coeff[0][:,:self.na], self.mf.mo_coeff[1][:,:self.nb])
        # Block diagonal alpha and beta virtual MOs
        Cv = utils.block_diag(self.mf.mo_coeff[0][:,self.na:], self.mf.mo_coeff[1][:,self.nb:])
        
        # Transform each block in spinorbitals
        oo = np.einsum('Ipq,pi,qj->Iij',self.gmatso,Co,Co)
        ov = np.einsum('Ipq,pi,qa->Iia',self.gmatso,Co,Cv)
        vo = np.einsum('Ipq,pa,qi->Iai',self.gmatso,Cv,Co)
        vv = np.einsum('Ipq,pa,qb->Iab',self.gmatso,Cv,Cv)
        g_mo_blocks = utils.one_e_blocks(oo,ov,vo,vv)
        return g_mo_blocks

    def hf_energy(self):
        ehf = 0.5*(np.einsum('ij,ji->',self.ptot,self.bare_fock) + np.einsum('ij,ji->',self.ptot,self.tmat))
        ehf = ehf + self.mol.energy_nuc()
        if self.shift:
            return ehf + self.const
        else:
            return ehf

    def kernel(self):
        '''Run CCSD calculation'''

        emp2 = ccsd_equations.mp2_energy(self, self.T1old, self.T2old)
        print('Fermionic MP2 energy: {}'.format(emp2))

        Eold = self.energy(amps='old', autogen=self.autogen)
        print('Initial CC amplitude energy: {}'.format(Eold))

        ethresh = self.options['ethresh']
        tthresh = self.options['tthresh']
        max_iter = self.options['max_iter']
        print('Energy threshold for convergence: {}'.format(ethresh))
        print('Amplitude threshold for convergence: {}'.format(tthresh))
        print('Maximum iterations: {}'.format(max_iter))
        if self.adiis != None:
            print('DIIS acceleration enabled with subspace size: {}'.format(self.adiis.space))
        else:
            print('DIIS acceleration not enabled...')
            print('Amplitude damping: {}'.format(self.options['damp']))
        print('')
        print('Iter.    E_corr      |Delta_amps|^2')
        converged = False
        self.iter = 0
        while self.iter < max_iter and not converged:

            # Update amplitudes from 'old' amplitudes to 'non-old' amps
            self.update_amps(autogen=self.autogen)

            # Norm of update
            res = self.res_norm()

            # Potentially damp/extrapolate the updates, returning the amps back to 'old'
            self.damp_update()

            # Update energy
            E = self.energy(amps='old', autogen=self.autogen)
            Ediff = abs(E - Eold)
            print(' {:2d}  {:.10f}   {:.4E}'.format(self.iter+1, E, res))
            if Ediff < ethresh and res < tthresh:
                converged = True
            Eold = E
            self.iter += 1
        
        if not converged:
            print("WARNING: eb-CCSD did not converge!")
        else:
            print("CC iterations converged!")

        # Point final values in 'old' to 'non-old'
        self.copy_amps()

        self.converged_t = converged
        self.e_corr = Eold

        return (self.ehf + Eold, self.e_corr)

    def energy(self, amps='old', autogen=False):
        ''' Compute energy from cc object, either from the 'old' or 'non-old' stored amplitudes '''

        if amps.lower() == 'old':
            if self.rank == (2, 0, 0):
                E = ccsd_equations.ccsd_energy(self, self.T1old, self.T2old, autogen=autogen)
            elif self.rank == (2, 1, 1):
                E = ccsd_1_1_equations.ccsd_1_1_energy(self, self.T1old, self.T2old, self.S1old, self.U11old)
            elif self.rank == (2, 2, 1):
                E = ccsd_2_1_equations.ccsd_2_1_energy(self, self.T1old, self.T2old, self.S1old, self.U11old)
            elif self.rank == (2, 2, 2):
                E = ccsd_2_2_equations.ccsd_2_2_energy(self, self.T1old, self.T2old, self.S1old, self.U11old)
            else:
                raise NotImplementedError
        else:
            if self.rank == (2, 0, 0):
                E = ccsd_equations.ccsd_energy(self, self.T1, self.T2, autogen=autogen)
            elif self.rank == (2, 1, 1):
                E = ccsd_1_1_equations.ccsd_1_1_energy(self, self.T1, self.T2, self.S1, self.U11, autogen=autogen)
            elif self.rank == (2, 2, 1):
                E = ccsd_2_1_equations.ccsd_2_1_energy(self, self.T1, self.T2, self.S1, self.U11, autogen=autogen)
            elif self.rank == (2, 2, 2):
                E = ccsd_2_2_equations.ccsd_2_2_energy(self, self.T1, self.T2, self.S1, self.U11, autogen=autogen)
            else:
                raise NotImplementedError
        
        return E

    def update_amps(self, autogen=False):
        '''Update amplitudes'''

        if self.rank == (2, 0, 0):
            T1, T2 = ccsd_equations.amp_updates_ccsd(self, autogen=autogen)
        elif self.rank == (2, 1, 1):
            T1, T2, S1, U11 = ccsd_1_1_equations.amp_updates_ccsd_1_1(self, autogen=autogen)
        elif self.rank == (2, 2, 1):
            T1, T2, S1, S2, U11 = ccsd_2_1_equations.amp_updates_ccsd_2_1(self, autogen=autogen)
        elif self.rank == (2, 2, 2):
            T1, T2, S1, S2, U11, U12 = ccsd_2_2_equations.amp_updates_ccsd_2_2(self, autogen=autogen)
        else:
            raise NotImplementedError

        # Divide by denominators
        self.T1 = T1 / self.D1.transpose((1, 0))
        self.T2 = T2 / self.D2.transpose((2, 3, 0, 1))

        if self.rank[1] >= 1:
            self.S1 = S1 / -self.omega
        if self.rank[1] == 2:
            self.S2 = S2 / self.Ds2
        if self.rank[2] >= 1:
            self.U11 = U11 / self.D1p.transpose((0, 2, 1))
        if self.rank[2] == 2:
            self.U12 = U12 / self.D2p.transpose((0, 1, 3, 2))

        return

    def vec_to_amps(self, vec, amps='old'):
        ''' Take a flattened vector of all amplitudes in the ansatz
            and distribute them back to the ebcc object amplitudes.
            By default, they will be returned to the 'old' amplitudes,
            unless amps is not set to 'old'. '''

        if amps == 'old':
            self.T1old = vec[:self.t1_bound].reshape((self.nv, self.no))
            self.T2old = vec[self.t1_bound:self.t2_bound].reshape((self.nv, self.nv, self.no, self.no))
            if self.rank[1] >= 1:
                self.S1old = vec[self.t2_bound:self.s1_bound].reshape((self.nbos))
            if self.rank[2] >= 1:
                self.U11old = vec[self.s1_bound:self.u11_bound].reshape((self.nbos, self.nv, self.no))
            if self.rank[1] == 2:
                self.S2old = vec[self.u11_bound:self.s2_bound].reshape((self.nbos, self.nbos))
            if self.rank[2] == 2:
                self.U12old = vec[self.s2_bound:].reshape((self.nbos, self.nbos, self.nv, self.no))
        else:
            self.T1 = vec[:self.t1_bound].reshape((self.nv, self.no))
            self.T2 = vec[self.t1_bound:self.t2_bound].reshape((self.nv, self.nv, self.no, self.no))
            if self.rank[1] >= 1:
                self.S1 = vec[self.t2_bound:self.s1_bound].reshape((self.nbos))
            if self.rank[2] >= 1:
                self.U11 = vec[self.s1_bound:self.u11_bound].reshape((self.nbos, self.no, self.nv))
            if self.rank[1] == 2:
                self.S2 = vec[self.u11_bound:self.s2_bound].reshape((self.nbos, self.nbos))
            if self.rank[2] == 2:
                self.U12 = vec[self.s2_bound:].reshape((self.nbos, self.nbos, self.nv, self.no))

        return None

    def amps_to_vec(self, amps='old'):
        ''' Flatten the amplitudes of the cc ansatz to a vector.
            Depending on whether amps='old' or 'new' as to whether
            amplitudes are taken from the 'old' or 'new' saved amplitudes.

            NOTE: No permutational symmetry of the amplitudes is being
            taken into account, which can mean that permutational symmetry may become
            broken...?
        '''

        vec = np.zeros((self.amp_vec_size))
        if amps == 'old':
            vec[:self.t1_bound] = self.T1old.ravel()
            vec[self.t1_bound:self.t2_bound] = self.T2old.ravel()
            if self.rank[1] >= 1:
                vec[self.t2_bound:self.s1_bound] = self.S1old.ravel()
            if self.rank[2] >= 1:
                vec[self.s1_bound:self.u11_bound] = self.U11old.ravel()
            if self.rank[1] == 2:
                vec[self.u11_bound:self.s2_bound] = self.S2old.ravel()
            if self.rank[2] == 2:
                vec[self.s2_bound:] = self.U12old.ravel()
        else:
            vec[:self.t1_bound] = self.T1.ravel()
            vec[self.t1_bound:self.t2_bound] = self.T2.ravel()
            if self.rank[1] >= 1:
                vec[self.t2_bound:self.s1_bound] = self.S1.ravel()
            if self.rank[2] >= 1:
                vec[self.s1_bound:self.u11_bound] = self.U11.ravel()
            if self.rank[1] == 2:
                vec[self.u11_bound:self.s2_bound] = self.S2.ravel()
            if self.rank[2] == 2:
                vec[self.s2_bound:] = self.U12.ravel()
        return vec

    def damp_update(self):
        ''' Damp the updates, returning the amps back to 'old' '''
       
        if self.adiis != None:
            # Turn 'current' (non-old) amplitudes into a vector
            vec = self.amps_to_vec(amps='new')
            vec_extrap = self.adiis.update(vec)
            self.vec_to_amps(vec_extrap, amps='old')
        else:
            # Just damp updates
            damp = self.options["damp"]

            self.T1old = damp*self.T1old + (1.0 - damp)*self.T1
            self.T2old = damp*self.T2old + (1.0 - damp)*self.T2
            if self.rank[1] >= 1:
                self.S1old = damp*self.S1old + (1.0 - damp)*self.S1
            if self.rank[1] == 2:
                self.S2old = damp*self.S2old + (1.0 - damp)*self.S2
            if self.rank[2] >= 1:
                self.U11old = damp*self.U11old + (1.0 - damp)*self.U11
            if self.rank[2] == 2:
                self.U12old = damp*self.U12old + (1.0 - damp)*self.U12

        return None

    def copy_amps(self):
        ''' Copy amplitudes from 'old' to 'non-old' '''

        self.T1 = self.T1old
        self.T2 = self.T2old
        if self.rank[1] >= 1:
            self.S1 = self.S1old
        if self.rank[1] == 2:
            self.S2 = self.S2old
        if self.rank[2] >= 1:
            self.U11 = self.U11old
        if self.rank[2] == 2:
            self.U12 = self.U12old

        return None

    def res_norm(self):
        ''' Find the norm of the difference between old and new amplitudes '''

        res = np.linalg.norm(self.T1old - self.T1) / np.sqrt(self.T1.size)
        res += np.linalg.norm(self.T2old - self.T2) / np.sqrt(self.T2.size)
        if self.rank[1] >= 1:
            res += np.linalg.norm(self.S1old - self.S1) / np.sqrt(self.S1.size)
        if self.rank[1] == 2:
            res += np.linalg.norm(self.S2old - self.S2) / np.sqrt(self.S2.size)
        if self.rank[2] >= 1:
            res += np.linalg.norm(self.U11old - self.U11) / np.sqrt(self.U11.size)
        if self.rank[2] == 2:
            res += np.linalg.norm(self.U12old - self.U12) / np.sqrt(self.U12.size)

        return res
