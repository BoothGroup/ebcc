import numpy as np
import os
import sys
from timeit import default_timer as timer
from qwick import codegen

try:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    rank = comm.Get_rank()
    size = comm.Get_size()
except ImportError:
    comm = None
    rank = 0
    size = 1

PYTHON_HEADER = """# Code generated by qwick.

import numpy as np
from pyscf import lib
from types import SimpleNamespace
from ebcc.codegen import common

"""

PYTHON_FOOTER = ""

LATEX_HEADER = r"""\documentclass{article}

\begin{document}

\title{Equations generated by {\tt qwick}.}
\maketitle

"""

LATEX_FOOTER = r"""

\end{document}"""


ov_2e = ["oooo", "ooov", "oovo", "ovoo", "vooo", "oovv", "ovov", "ovvo", "voov", "vovo", "vvoo", "ovvv", "vovv", "vvov", "vvvo", "vvvv"]
ov_1e = ["oo", "ov", "vo", "vv"]


CACHE_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "cache.pkl")

def cache(func):
    """Cache output of function in a pickle file.
    """

    def wrapper(*args, **kwargs):
        key = hash((func, *args, *tuple(kwargs.items())))

        if not os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, "wb") as f:
                pickle.dump({}, f)

        with open(CACHE_FILE, "rb") as f:
            data = pickle.load(f)

        if key not in data:
            res = func(*args, **kwargs)
            data[key] = res
            with open(CACHE_FILE, "wb") as f:
                pickle.write(data, f)

        return data[key]

    return wrapper


# Default particle types:
particles = {
        # Fermionic hamiltonian elements:
        "f": ((codegen.FERMION, 0), (codegen.FERMION, 0)),
        "v": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 1)),
        # Bosonic hamiltonian elements:
        "G": ((codegen.SCALAR_BOSON, 0),),
        "w": ((codegen.SCALAR_BOSON, 0), (codegen.SCALAR_BOSON, 1)),
        # Fermion-boson coupling:
        "g": ((codegen.SCALAR_BOSON, 0), (codegen.FERMION, 1), (codegen.FERMION, 1)),
        "gc": ((codegen.SCALAR_BOSON, 0), (codegen.FERMION, 1), (codegen.FERMION, 1)),
        # Amplitudes:
        "t1": ((codegen.FERMION, 0), (codegen.FERMION, 0)),
        "t2": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 1)),
        "s1": ((codegen.SCALAR_BOSON, 0),),
        "s2": ((codegen.SCALAR_BOSON, 0), (codegen.SCALAR_BOSON, 0)),
        "u11": ((codegen.SCALAR_BOSON, 0), (codegen.FERMION, 1), (codegen.FERMION, 1)),
        # Lambda amplitudes:
        "l1": ((codegen.FERMION, 0), (codegen.FERMION, 0)),
        "l2": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 1)),
        "ls1": ((codegen.SCALAR_BOSON, 0),),
        "ls2": ((codegen.SCALAR_BOSON, 0), (codegen.SCALAR_BOSON, 0)),
        "lu11": ((codegen.SCALAR_BOSON, 0), (codegen.FERMION, 1), (codegen.FERMION, 1)),
        # Excitation operators:
        "r1": ((codegen.FERMION, 0),),
        "r2": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0)),
        **{"r1_%s" % x: ((codegen.FERMION, 0), (codegen.FERMION, 0),) for x in ["o", "v"]},
        **{"r2_%s" % x: ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 1)) for x in ["o", "v"]},
        # Updates:
        "t1new": ((codegen.FERMION, 0), (codegen.FERMION, 0)),
        "t2new": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 1)),
        "s1new": ((codegen.SCALAR_BOSON, 0),),
        "s2new": ((codegen.SCALAR_BOSON, 0), (codegen.SCALAR_BOSON, 0)),
        "u11new": ((codegen.SCALAR_BOSON, 0), (codegen.FERMION, 1), (codegen.FERMION, 1)),
        "l1new": ((codegen.FERMION, 0), (codegen.FERMION, 0)),
        "l2new": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 1)),
        "ls1new": ((codegen.SCALAR_BOSON, 0),),
        "ls2new": ((codegen.SCALAR_BOSON, 0), (codegen.SCALAR_BOSON, 0)),
        "lu11new": ((codegen.SCALAR_BOSON, 0), (codegen.FERMION, 1), (codegen.FERMION, 1)),
        "r1new": ((codegen.FERMION, 0),),
        "r2new": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0)),
        # Delta function:
        "delta": ((codegen.FERMION, 0), (codegen.FERMION, 0)),
        # Density matrices:
        **{"rdm1_f_%s" % x: ((codegen.FERMION, 0), (codegen.FERMION, 0)) for x in ov_1e},
        **{"rdm2_f_%s" % x: ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 1)) for x in ov_2e},
        "rdm1_b": ((codegen.BOSON, 0), (codegen.BOSON, 0)),
        **{"dm_b%s" % x: ((codegen.BOSON, 0),) for x in ("", "_cre", "_des")},
        **{"rdm_eb_%s_%s" % (x, y): ((codegen.BOSON, 0), (codegen.FERMION, 1), (codegen.FERMION, 1)) for y in ov_1e for x in ("cre", "des")},
        # Hbar elements:
        "h11": ((codegen.FERMION, 0), (codegen.FERMION, 0)),
        "h22": ((codegen.FERMION, 0), (codegen.FERMION, 1), (codegen.FERMION, 0), (codegen.FERMION, 2), (codegen.FERMION, 3), (codegen.FERMION, 2)),  # FIXME?
}


# Default printer
def get_printer(spin):
    reorder_axes = {
            # TODO remove:
            "l1new": (1, 0),
            "l2new": (2, 3, 0, 1),
            "lu11new": (0, 2, 1),
    }

    if spin == "rhf":
        reorder_axes["v"] = (0, 2, 1, 3)
        for x in ov_2e:
            reorder_axes["rdm2_f_%s" % x] = (0, 2, 1, 3)

    printer = codegen.EinsumPrinter(
            occupancy_tags={
                "v": "{base}.{tags}",
                "f": "{base}.{tags}",
                "g": "{base}.{tags}",
                "gc": "{base}.{tags}",
                "delta": "delta_{tags}",
            },
            reorder_axes=reorder_axes,
            remove_spacing=True,
            garbage_collection=True,
            base_indent=1,
            einsum="lib.einsum",
            zeros="np.zeros",
            dtype="np.float64",
    )

    return printer


# Prefix and spin transformation function
def get_transformation_function(spin):
    if spin == "rhf":
        transform_spin = lambda terms, indices, **kwargs: codegen.ghf_to_rhf(terms, indices, **kwargs)
        prefix = "r"
    elif spin == "uhf":
        transform_spin = lambda terms, indices, **kwargs: codegen.ghf_to_uhf(terms, indices, **kwargs)
        prefix = "u"
    elif spin == "ghf":
        transform_spin = lambda terms, indices, **kwargs: terms
        prefix = "g"

    return transform_spin, prefix


class FilePrinter:
    def __init__(self, name):
        if rank != 0:
            return
        if len(sys.argv) == 1 or sys.argv[1] != "dummy":
            self.python_file = open("%s.py" % name, "w")
            self.latex_file = open("%s.tex" % name, "w")
        else:
            self.python_file = sys.stdout
            self.latex_file = open(os.devnull, "w")

    def __enter__(self):
        if rank != 0:
            return self
        # Initialise the Python file:
        self.python_file.write(PYTHON_HEADER)
        # Initialise the LaTeX file:
        self.latex_file.write(LATEX_HEADER)
        return self

    def __exit__(self, *args, **kwargs):
        if rank != 0:
            return
        # Exit the python file:
        self.python_file.write(PYTHON_FOOTER)
        self.python_file.close()
        # Exit the LaTeX file:
        self.latex_file.write(LATEX_FOOTER)
        self.latex_file.close()


class FunctionPrinter:
    def __init__(self, file_printer, name, args, res, remove_f_diagonal=False, return_dict=True, timer=None):
        self.file_printer = file_printer
        self.name = name
        self.args = args
        self.res = res
        self.remove_f_diagonal = remove_f_diagonal
        self.return_dict = return_dict
        self.timer = timer

    def write_python(self, string, comment=None):
        if rank != 0:
            return
        if comment:
            self.file_printer.python_file.write("    # %s\n" % comment)
        self.file_printer.python_file.write(string)
        self.file_printer.python_file.write("\n")
        self.file_printer.python_file.flush()

    def write_latex(self, string, comment=None):
        if rank != 0:
            return
        if comment:
            self.file_printer.latex_file.write(comment + ":\n\n")
        self.file_printer.latex_file.write("$$" + string + "$$")
        self.file_printer.latex_file.write("\n\n")
        self.file_printer.latex_file.flush()

    def __enter__(self):
        if rank != 0:
            return self
        # Initialise python function
        self.write_python("def %s(%s, **kwargs):" % (
            self.name, ", ".join(["%s=None" % arg for arg in self.args])
        ))
        if self.remove_f_diagonal:
            self.write_python(
                    "    # Remove diagonal from Fock:\n"
                    "    f = SimpleNamespace(\n"
                    "        oo=f.oo-np.diag(np.diag(f.oo)),\n"
                    "        ov=f.ov,\n"
                    "        vo=f.vo,\n"
                    "        vv=f.vv-np.diag(np.diag(f.vv)),\n"
                    "    )\n"
            )
        return self

    def __exit__(self, *args, **kwargs):
        if rank != 0:
            return
        # Return from python function
        if self.return_dict:
            res = "{" + ", ".join(["\"%s\": %s" % (v, v) for v in self.res]) + "}"
        else:
            res = ", ".join(self.res)
        self.write_python("    return %s\n" % res)
        if self.timer is not None:
            print("Time for %s: %.5f s" % (self.name, self.timer()))


class Stopwatch:
    def __init__(self):
        self._t0 = timer()
        self._t = timer()

    def split(self):
        t = timer() - self._t0
        return t

    def lap(self):
        t = timer() - self._t
        self._t = timer()
        return t

    def reset(self):
        self.__init__()
        return self

    __call__ = lap


def pack_2e(*args):
    # args should be in the order of ov_2e

    assert len(args) == len(ov_2e)

    nocc = args[0].shape[0]
    nvir = args[-1].shape[-1]
    occ = slice(None, nocc)
    vir = slice(nocc, None)
    out = np.zeros((nocc+nvir,) * 4)

    for key, arg in zip(ov_2e, args):
        slices = [occ if x == "o" else vir for x in key]
        out[tuple(slices)] = arg

    return out
