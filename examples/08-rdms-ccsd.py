''' Compute RDMs from ebcc. Test agreement with pyscf.'''

import numpy as np
import pyscf
from pyscf import ao2mo, scf
from pyscf import cc as pyscf_cc
from ebcc import ebccsd, utils

mol = pyscf.M(
    atom = 'H 0 0 0; F 0 0 1.1',
    basis = 'cc-pvdz')
# There is a small amount of symmetry breaking in this system.
mf = mol.UHF().run()

# Set up cc object and run kernel for T-amplitude optimization (no bosons)
cc = ebccsd.EBCCSD.fromUHFobj(mf, options={'tthresh': 1e-11, 'diis space': 12}, autogen_code=True)
ecorr = cc.kernel()
print('EBCCSD correlation energy', cc.e_corr)

# Solve lambda equations
cc.solve_lambda()

# Generate 1 and 2 RDMs, from both autogenerated code and optimized code (for testing accuracy)
dm1_eb = cc.make_1rdm_f(autogen=False)
dm2_eb = cc.make_2rdm_f(autogen=False)
dm1_eb_autogen = cc.make_1rdm_f(autogen=True)
dm2_eb_autogen = cc.make_2rdm_f(autogen=True)

# Generate reference pyscf values
mycc = mf.CCSD()
mycc.conv_tol = 1.e-12
mycc.conv_tol_normt = 1.e-11
mycc.kernel()
print('CCSD correlation energy', mycc.e_corr)
dm1 = mycc.make_rdm1()
dm2 = mycc.make_rdm2()

# Check that the RDM autogenerated code is the same
assert(np.allclose(dm1_eb,dm1_eb_autogen))
assert(np.allclose(dm2_eb,dm2_eb_autogen))
print('Autogenerated code and optimized code agrees')

assert(np.allclose(cc.e_corr,mycc.e_corr))
print('EXCELLENT: CCSD correlation energies agree between pyscf and ebcc')

# Check symmetries of GHF dm2
assert(np.allclose(dm2_eb, dm2_eb.transpose(1,0,3,2)))
assert(np.allclose(dm2_eb, -dm2_eb.transpose(2,1,0,3)))
assert(np.allclose(dm2_eb, -dm2_eb.transpose(0,3,2,1)))

nspato = mf.mol.nao_nr()
na = sum(mf.mo_occ[0] > 0.0)
nb = sum(mf.mo_occ[1] > 0.0)
va = nspato - na
vb = nspato - nb
no = na + nb
nv = va + vb

# Check the alpha block of the lambda and T amplitudes agree with pyscf
assert(np.allclose(cc.T1[:va, :na], mycc.t1[0].T))
assert(np.allclose(cc.T2[:va, :va, :na, :na], mycc.t2[0].transpose(3, 2, 1, 0)))
assert(np.allclose(cc.T2, -cc.T2.transpose(1,0,2,3))) # Antisymmetric wrt permutation of virtual indices
assert(np.allclose(cc.T2, -cc.T2.transpose(0,1,3,2))) # Antisymmetric wrt permutation of virtual indices
assert(np.allclose(cc.L1[:na, :va], mycc.l1[0]))
assert(np.allclose(cc.L2[:na, :na, :va, :va], mycc.l2[0]))
assert(np.allclose(cc.L2, -cc.L2.transpose(1,0,2,3))) # Antisym wrt permute occ indices
assert(np.allclose(cc.L2, -cc.L2.transpose(0,1,3,2))) # Antisym wrt permute virt indices
print('T and L amplitudes agree between pyscf and ebcc')

print('Checking ebcc vs. pyscf RDMs: ')
# NOTE: ordering is different.
# ebcc returns objects as occ_a, occ_b, virt_a, virt_b.
assert(np.allclose(dm1_eb[:na, :na], dm1[0][:na, :na]))
print('occ-occ 1rdm block correct')
assert(np.allclose(dm1_eb[no:no+va, no:no+va], dm1[0][na:, na:]))
print('virt-virt 1rdm block correct')
#print(dm1_eb[:cc.na, cc.no:cc.no+cc.va]-dm1[0][:cc.na, cc.na:])
assert(np.allclose(dm1_eb[:na, no:no + va], dm1[0][:na, na:]))
print('occ-virt 1rdm block correct')
assert(np.allclose(dm1_eb[no:no+va, :na], dm1[0][na:, :na]))
print('virt-occ 1rdm block correct')

# We reorder the pyscf RDMs to compare to our ebcc RDMs, by constructing the spinorbital
# RDMs of pyscf in the relevant ordering.
dm2_pyscf_ghf = np.zeros_like(dm2_eb)
# Mask orbitals in each spin channel 
mask_a = [True] * na + [False] * nb + [True] * va + [False] * vb
mask_b = [not elem for elem in mask_a]
dm2_pyscf_ghf[np.ix_(mask_a,mask_a,mask_a,mask_a)] = dm2[0]
dm2_pyscf_ghf[np.ix_(mask_b,mask_b,mask_b,mask_b)] = dm2[2]
dm2_pyscf_ghf[np.ix_(mask_a,mask_a,mask_b,mask_b)] = dm2[1]
dm2_pyscf_ghf[np.ix_(mask_b,mask_b,mask_a,mask_a)] = dm2[1].transpose(2,3,0,1)  # switch electrons
dm2_pyscf_ghf[np.ix_(mask_b,mask_a,mask_a,mask_b)] = -dm2[1].transpose(2,1,0,3) # switch annihilators
dm2_pyscf_ghf[np.ix_(mask_a,mask_b,mask_b,mask_a)] = -dm2[1].transpose(0,3,2,1) # switch creators
# Check individual blocks, and the whole GHF 2RDM matrix
assert(np.allclose(dm2_pyscf_ghf[np.ix_(mask_a,mask_a,mask_a,mask_a)], dm2_eb[np.ix_(mask_a,mask_a,mask_a,mask_a)]))
assert(np.allclose(dm2_pyscf_ghf[np.ix_(mask_b,mask_b,mask_b,mask_b)], dm2_eb[np.ix_(mask_b,mask_b,mask_b,mask_b)]))
assert(np.allclose(dm2_pyscf_ghf[np.ix_(mask_a,mask_a,mask_b,mask_b)], dm2_eb[np.ix_(mask_a,mask_a,mask_b,mask_b)]))
assert(np.allclose(dm2_pyscf_ghf[np.ix_(mask_b,mask_b,mask_a,mask_a)], dm2_eb[np.ix_(mask_b,mask_b,mask_a,mask_a)]))
assert(np.allclose(dm2_pyscf_ghf[np.ix_(mask_a,mask_b,mask_a,mask_b)], dm2_eb[np.ix_(mask_a,mask_b,mask_a,mask_b)]))
assert(np.allclose(dm2_pyscf_ghf[np.ix_(mask_a,mask_b,mask_b,mask_a)], dm2_eb[np.ix_(mask_a,mask_b,mask_b,mask_a)]))
assert(np.allclose(dm2_eb, dm2_pyscf_ghf))
print('All 2RDM blocks agree')

# Alternatively, we could reorder the ebcc RDMs to the GHF fully energy ordered basis using in-built function.
# We can then directly compare to the pyscf GHF cc implementation
dm1_eb_ghf = utils.reorder_to_ghf(mf, dm1_eb)
dm2_eb_ghf = utils.reorder_to_ghf(mf, dm2_eb)
# Convert pyscf cc object to ghf
mycc_ghf = pyscf_cc.addons.convert_to_gccsd(mycc)
# Change lambda amplitudes to spinorbitals (this is not performed in the function above) 
mycc_ghf.l1 = pyscf_cc.addons.spatial2spin(mycc_ghf.l1, mycc_ghf._scf.mo_coeff.orbspin)
mycc_ghf.l2 = pyscf_cc.addons.spatial2spin(mycc_ghf.l2, mycc_ghf._scf.mo_coeff.orbspin)
# Generate pyscf ghf matrices
dm1_ghf = mycc_ghf.make_rdm1()
dm2_ghf = mycc_ghf.make_rdm2()
assert(np.allclose(dm1_ghf, dm1_eb_ghf))
assert(np.allclose(dm2_ghf, dm2_eb_ghf))

# Useful function for debugging
def print_errors(mat,mat_pyscf,atol=1.e-7):
    np.set_printoptions(edgeitems=30, linewidth=100000)
    ndim = mat.ndim
    if not np.allclose(mat, mat_pyscf):
        print('Errors found')
        mask = np.abs(mat - mat_pyscf) > atol
        for i in range(ndim):
            print(np.where(mask)[i])
        print('My values: ')
        print(mat[mask])
        print('Benchmark values: ')
        print(mat_pyscf[mask])
        print('Difference: ')
        print(mat[mask]-mat_pyscf[mask])
        print('Ratio: ')
        print(mat[mask]/mat_pyscf[mask])
    return
